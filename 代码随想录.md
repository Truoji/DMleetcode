# 一、数组

## 1、二分查找

要实现二分查找，主要判断边界条件和数据溢出的情况，利用双指针进行操作

```python
def binary_sort(nums, target):
    left = 0
    right = len(nums) - 1
    # 使用左闭右闭区间
    while left <= right:
        mid = (right - left) // 2 + left  # 防止数据溢出，int型左右相加会导致数据溢出     
        if target == nums[mid]:
            return mid
        elif target < nums[mid]:
            right = mid - 1	# 当目标值小于中间值的时候，让右边界变成 mid 左边的那个值
        else:
            left = mid + 1  # 当目标值大于中间值的时候，让左边界变成 mid 右边的那个值
        # 三个判断结束后，再次判断 left 和 right 值的关系， 然后再给 mid 赋值，继续判断
    return -1
```



## 2、移除元素（实现一个erase()函数，快慢双指针）

可以使用内置函数直接实现，erase() 是一个能实现删除的函数，主要是string字符串中的函数

list中的remove(val)主要是删除从左往右遍历的第一个val值

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:

        slow = 0  # 定义一个慢指针
        for fast in range(len(nums)):  # 让快指针进行遍历
            # 当快指针遍历到的值不是我要删除的值的时候，让快指针的值取覆盖慢指针，并移动
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
		# 当快指针指向的值是要删除的值的时候，上面的条件不满足，继续移动快指针
        
        # 循环结束后返回慢指针长度的数组
        return slow
```

```c++
// 同理使用 C++实现
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.size(); fast++){
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;

    }
}
```



## 3、有序数组的平方（双指针）

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

利用双指针，从列表的两端向中间进行移动，因为给的`nums`有负数，平方之后最大的只会出现在两头，所以从两端移动

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        result = [] 	# 定义一个返回数组
        left = 0	# 左指针
        right = len(nums) - 1	# 右指针

        while left <= right:
            # 左大左移动
            if (nums[left]*nums[left] > nums[right]*nums[right]):
                result.append(nums[left]*nums[left])
                left += 1
            else:
                result.append(nums[right]*nums[right])
                right -= 1
        

        return result[::-1]

```



## 4、长度最小的子数组和（滑动窗口）

涉及到连续子数组问题时，首先要想到滑动窗口法

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。只用一个`for`循环，那么指向的一定是终止位置

```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)

        i = 0 # 起始位置
        sum = 0
        result = float("inf") 
        for j in range(n):
            sum += nums[j]
            while sum >= target:
                # 更新起始坐标
                subL = j-i+1
                result = min(result, subL)
                sum -= nums[i]
                i += 1
        return 0 if result == float("inf") else result
```

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size();
        int i = 0; // 起始坐标
        int sum = 0; // 子序列累加和
        int res = INT32_MAX; //定义一个无穷大的数
        int subL = 0;

        for (int j = 0; j < len; j++) {
            sum += nums[j]; //向后累加求出序列和
            while (sum >= target) {
                // 移动起始坐标
                subL = j - i + 1;
                res = min(res, subL);
                sum -= nums[i];
                i++;       
            }
        }
        return res == INT32_MAX? 0:res;

    }
};
```



## 5、螺旋矩阵

主要对应相同的

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        x = 0
        y = 0
        loop, mid = n //2, n//2 # 循环圈数，中心点数
        count = 1
        nums = [[0] * n for _ in range(n)]
        # 左闭右开
        for offset in range(1, loop+1):   # 每循环一层偏移量加1，偏移量从1开始
            for i in range(x, n-offset): #从左到右
                nums[x][i] = count
                count += 1
            for i in range(y, n-offset):
                nums[i][n-offset] = count
                count += 1
            for i in range(n-offset, x, -1):
                nums[n-offset][i] = count
                count += 1
            for i in range(n-offset, y, -1):
                nums[i][y] = count
                count +=1
            x+=1 	# 更新起始点
            y+=1
        
        if n %2 == 1: # n为奇数时，填充中心点
            nums[mid][mid] = count
        return nums
```

# 二、链表

## 1、删除链表元素

使用一个虚拟头节点`dummyHead`统一标准，在头节点前面加一个虚拟头节点，然后使用`cur`遍历整个链表，当`cur.next`是我要删除的元素后，将`cur.next`指向`cur.next.next`

**要注意**返回的时候要返回`dummyhead.next`，因为头节点可能被删除了，但是`dummyhead.next`指向的一定不会变

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyhead = ListNode(next=head)
        cur = dummyhead

        while cur.next is not None:
            if cur.next.val == val:
                cur.next = cur.next.next
            
            else:
                cur = cur.next
        
        return dummyhead.next
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next; //主动释放内存
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```



## 3、反转链表（双指针法，递归）

主要考虑在实现中设置一个`cur = head  和   pre = NULL`，然后进行反向指，当断开指向的时候，先申请一个临时节点`temp`存储`cur.next`，然后正常循环。

```Py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        
        while cur is not None:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp   	
        return pre
```



```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        def reverse(cur, pre):
            if (cur == None):
                return pre
            temp = cur.next
            cur.next = pre
            return reverse(temp, cur)

        return reverse(head, None)
```

使用递归主要看传入参数，对比双指针法来写，实现更好的返回

```C++
class Solution {
public:
    ListNode* reverse(ListNode* cur, ListNode* pre) {
        if(cur == NULL) return pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(temp, cur);
    }
    ListNode* reverseList(ListNode* head) {
        return reverse(head, NULL);
        
    }
};
```

使用Python的特性直接进行赋值，不会改变中间的值造成断链，一句代码即可完成

## 4、两两交换链表中的节点()

还是使用虚拟头节点`dummyHead`将链表打通，然后在改变指向的时候注意先保存好指向的内容，然后在进行修改。

`dummyHead`的构建方式要牢记，分别是

`dummyHead = ListNode(next=head)`和`ListNode* dummyHead = new ListNode(0); dummyHead->next = head;`

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 构建虚拟头节点
        dummyHead->next = head; // 虚拟头节点指向链表头
        ListNode* pre = dummyHead; // 构建指针指向虚拟头节点
		// 判断条件为，当指针指向的下一个节点不为空（偶数节点）并且指针指向的下下个节点不为空（奇数节点）,两者不能交换，否则会导致指针异常
        while (pre->next != nullptr && pre->next->next != nullptr) {
            // pre cur post分别表示左、中、右三个节点，先保存好他们的节点信息，这样交换位置时不出错
            ListNode* cur = pre->next; 	
            ListNode* post = pre->next->next;

            cur->next = post->next; 
            post->next = cur;
            pre->next = post;

            pre = pre->next->next; // 每隔两个交换链表
        }
        return dummyHead->next; //返回的一定是虚拟头节点指向的下一个

    }
};
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(next = head)
        pre = dummyHead

        while pre.next and pre.next.next:
            cur = pre.next
            post = pre.next.next

             # pre，cur，post对应最左，中间的，最右边的节点
            cur.next = post.next
            post.next = cur
            pre.next = post

            pre = pre.next.next

        return dummyHead.next
```

## 5、删除链表的倒数第n个节点（双指针法）

设置快慢两个指针，先让快指针走n步，然后再让慢指针走，这样慢指针指向的那个就是需要删除的节点，但是因为删除节点需要删除的节点之前那个，所以修改判断条件晚走一步。同时也要注重使用虚拟头节点，这样不用判断头节点被删除的情况。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* pre = dummyHead;
        ListNode* cur = dummyHead;

        while (n) {
            cur = cur->next;
            n--;
        }
        while (cur->next) {
            cur = cur->next;
            pre = pre->next;
        }
        pre->next = pre->next->next;

        return dummyHead->next;

    }
};
```

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(next=head)
        cur = dummyHead
        pre = dummyHead

        while n+1:
            cur = cur.next
            n -= 1
        
        while cur:
            cur = cur.next
            pre = pre.next
      
        pre.next = pre.next.next

        return dummyHead.next
```

## 6、环形链表（快慢双指针，利用速度判断）

1.判断是否有环：首先定义快慢两个指针，快指针走两步，慢指针走一步，如果有环，那么在环内因为快指针相对慢指针多走一步，在环内一定相遇，如果环内相遇，则进行下一步判断入口

2、涉及数学问题，如果将 指针`A` 定义为头节点，指针`B`定义为相遇点，那么在`AB`相遇处即为环的入口

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;  //定义快慢双指针
        ListNode* slow = head;

        while (fast and fast->next) {  // 只有当快指针的下一个不为NULL的时候，才能保证是环
            fast = fast->next->next; // 快指针移动两步
            slow = slow->next; // 满指针移动一步
            if (fast == slow) { //当快慢指针相遇的时候，证明有环，则进行入口处判断
                ListNode* index1 = fast;  // 定义在相遇点
                ListNode* index2 = head； // 定义在链表头
                while(index1 != index2) {
                    index1 = index1->next; 
                    index2 = index2->next;
                }
                return index1; //如果相遇了，返回相遇点，并且此处是入口处，详细看代码随想录的数学推导
            }
        }
        return NULL;     
    }
};
```

# 三、哈希表

总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

常用的哈希函数：数组，map，set



## 1、有效的字母异位词

因为字母是有限的，可以用数组来设计哈希

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int hash[26] ={0};
        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
        for (int i = 0; i < s.size(); i++) {
            hash[s[i] - 'a']++; 
        }
        for (int i = 0; i < t.size(); i++) {
            hash[t[i] - 'a']--;
        }
        for (int i=0; i<26; i++) {
            // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if (hash[i] != 0) {
                return false;
            }
        }
         // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        hash = [0]*26
        
        for i in s:
            # 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            hash[ord(i) - ord("a")] += 1
        for i in t:
            hash[ord(i) - ord("a")] -= 1
        for i in range(26):
            # record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if hash[i] != 0:
                return False
        return True
```

## 2、两个数的交集（set容器的过渡）

在 C++中，考虑set的三种方式：`set   unordered_set   multiset`(**需要后面再看视频教程补充**)

由于题目的要求更改，可以用数组实现hash

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

