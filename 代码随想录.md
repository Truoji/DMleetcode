# 一、数组

## 1、二分查找

要实现二分查找，主要判断边界条件和数据溢出的情况，利用双指针进行操作

```python
def binary_sort(nums, target):
    left = 0
    right = len(nums) - 1
    # 使用左闭右闭区间
    while left <= right:
        mid = (right - left) // 2 + left  # 防止数据溢出，int型左右相加会导致数据溢出     
        if target == nums[mid]:
            return mid
        elif target < nums[mid]:
            right = mid - 1	# 当目标值小于中间值的时候，让右边界变成 mid 左边的那个值
        else:
            left = mid + 1  # 当目标值大于中间值的时候，让左边界变成 mid 右边的那个值
        # 三个判断结束后，再次判断 left 和 right 值的关系， 然后再给 mid 赋值，继续判断
    return -1
```



## 2、移除元素（实现一个erase()函数，快慢双指针）

可以使用内置函数直接实现，erase() 是一个能实现删除的函数，主要是string字符串中的函数

list中的remove(val)主要是删除从左往右遍历的第一个val值

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:

        slow = 0  # 定义一个慢指针
        for fast in range(len(nums)):  # 让快指针进行遍历
            # 当快指针遍历到的值不是我要删除的值的时候，让快指针的值取覆盖慢指针，并移动
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
		# 当快指针指向的值是要删除的值的时候，上面的条件不满足，继续移动快指针
        
        # 循环结束后返回慢指针长度的数组
        return slow
```

```c++
// 同理使用 C++实现
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.size(); fast++){
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;

    }
}
```



## 3、有序数组的平方（双指针）

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

利用双指针，从列表的两端向中间进行移动，因为给的`nums`有负数，平方之后最大的只会出现在两头，所以从两端移动

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        result = [] 	# 定义一个返回数组
        left = 0	# 左指针
        right = len(nums) - 1	# 右指针

        while left <= right:
            # 左大左移动
            if (nums[left]*nums[left] > nums[right]*nums[right]):
                result.append(nums[left]*nums[left])
                left += 1
            else:
                result.append(nums[right]*nums[right])
                right -= 1
        

        return result[::-1]

```



## 4、长度最小的子数组和（滑动窗口）

涉及到连续子数组问题时，首先要想到滑动窗口法

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。只用一个`for`循环，那么指向的一定是终止位置

```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)

        i = 0 # 起始位置
        sum = 0
        result = float("inf") 
        for j in range(n):
            sum += nums[j]
            while sum >= target:
                # 更新起始坐标
                subL = j-i+1
                result = min(result, subL)
                sum -= nums[i]
                i += 1
        return 0 if result == float("inf") else result
```

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size();
        int i = 0; // 起始坐标
        int sum = 0; // 子序列累加和
        int res = INT32_MAX; //定义一个无穷大的数
        int subL = 0;

        for (int j = 0; j < len; j++) {
            sum += nums[j]; //向后累加求出序列和
            while (sum >= target) {
                // 移动起始坐标
                subL = j - i + 1;
                res = min(res, subL);
                sum -= nums[i];
                i++;       
            }
        }
        return res == INT32_MAX? 0:res;

    }
};
```



## 5、螺旋矩阵

主要对应相同的

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        x = 0
        y = 0
        loop, mid = n //2, n//2 # 循环圈数，中心点数
        count = 1
        nums = [[0] * n for _ in range(n)]
        # 左闭右开
        for offset in range(1, loop+1):   # 每循环一层偏移量加1，偏移量从1开始
            for i in range(x, n-offset): #从左到右
                nums[x][i] = count
                count += 1
            for i in range(y, n-offset):
                nums[i][n-offset] = count
                count += 1
            for i in range(n-offset, x, -1):
                nums[n-offset][i] = count
                count += 1
            for i in range(n-offset, y, -1):
                nums[i][y] = count
                count +=1
            x+=1 	# 更新起始点
            y+=1
        
        if n %2 == 1: # n为奇数时，填充中心点
            nums[mid][mid] = count
        return nums
```

# 二、链表

## 1、删除链表元素

使用一个虚拟头节点`dummyHead`统一标准，在头节点前面加一个虚拟头节点，然后使用`cur`遍历整个链表，当`cur.next`是我要删除的元素后，将`cur.next`指向`cur.next.next`

**要注意**返回的时候要返回`dummyhead.next`，因为头节点可能被删除了，但是`dummyhead.next`指向的一定不会变

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyhead = ListNode(next=head)
        cur = dummyhead

        while cur.next is not None:
            if cur.next.val == val:
                cur.next = cur.next.next
            
            else:
                cur = cur.next
        
        return dummyhead.next
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next; //主动释放内存
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```



## 3、翻转链表（双指针法，递归）

主要考虑在实现中设置一个`cur = head  和   pre = NULL`，然后进行反向指，当断开指向的时候，先申请一个临时节点`temp`存储`cur.next`，然后正常循环。

```Py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        
        while cur is not None:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp   	
        return pre
```



```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        def reverse(cur, pre):
            if (cur == None):
                return pre
            temp = cur.next
            cur.next = pre
            return reverse(temp, cur)

        return reverse(head, None)
```

使用递归主要看传入参数，对比双指针法来写，实现更好的返回

```C++
class Solution {
public:
    ListNode* reverse(ListNode* cur, ListNode* pre) {
        if(cur == NULL) return pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(temp, cur);
    }
    ListNode* reverseList(ListNode* head) {
        return reverse(head, NULL);
        
    }
};
```

使用Python的特性直接进行赋值，不会改变中间的值造成断链，一句代码即可完成

## 4、两两交换链表中的节点()

还是使用虚拟头节点`dummyHead`将链表打通，然后在改变指向的时候注意先保存好指向的内容，然后在进行修改。

`dummyHead`的构建方式要牢记，分别是

`dummyHead = ListNode(next=head)`和`ListNode* dummyHead = new ListNode(0); dummyHead->next = head;`

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 构建虚拟头节点
        dummyHead->next = head; // 虚拟头节点指向链表头
        ListNode* pre = dummyHead; // 构建指针指向虚拟头节点
		// 判断条件为，当指针指向的下一个节点不为空（偶数节点）并且指针指向的下下个节点不为空（奇数节点）,两者不能交换，否则会导致指针异常
        while (pre->next != nullptr && pre->next->next != nullptr) {
            // pre cur post分别表示左、中、右三个节点，先保存好他们的节点信息，这样交换位置时不出错
            ListNode* cur = pre->next; 	
            ListNode* post = pre->next->next;

            cur->next = post->next; 
            post->next = cur;
            pre->next = post;

            pre = pre->next->next; // 每隔两个交换链表
        }
        return dummyHead->next; //返回的一定是虚拟头节点指向的下一个

    }
};
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(next = head)
        pre = dummyHead

        while pre.next and pre.next.next:
            cur = pre.next
            post = pre.next.next

             # pre，cur，post对应最左，中间的，最右边的节点
            cur.next = post.next
            post.next = cur
            pre.next = post

            pre = pre.next.next

        return dummyHead.next
```

## 5、删除链表的倒数第n个节点（双指针法）

设置快慢两个指针，先让快指针走n步，然后再让慢指针走，这样慢指针指向的那个就是需要删除的节点，但是因为删除节点需要删除的节点之前那个，所以修改判断条件晚走一步。同时也要注重使用虚拟头节点，这样不用判断头节点被删除的情况。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* pre = dummyHead;
        ListNode* cur = dummyHead;

        while (n) {
            cur = cur->next;
            n--;
        }
        while (cur->next) {
            cur = cur->next;
            pre = pre->next;
        }
        pre->next = pre->next->next;

        return dummyHead->next;

    }
};
```

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(next=head)
        cur = dummyHead
        pre = dummyHead

        while n+1:
            cur = cur.next
            n -= 1
        
        while cur:
            cur = cur.next
            pre = pre.next
      
        pre.next = pre.next.next

        return dummyHead.next
```

## **缺网站上第七题：链表相交**

## 6、环形链表（快慢双指针，利用速度判断）

1.判断是否有环：首先定义快慢两个指针，快指针走两步，慢指针走一步，如果有环，那么在环内因为快指针相对慢指针多走一步，在环内一定相遇，如果环内相遇，则进行下一步判断入口

2、涉及数学问题，如果将 指针`A` 定义为头节点，指针`B`定义为相遇点，那么在`AB`相遇处即为环的入口

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;  //定义快慢双指针
        ListNode* slow = head;

        while (fast and fast->next) {  // 只有当快指针的下一个不为NULL的时候，才能保证是环
            fast = fast->next->next; // 快指针移动两步
            slow = slow->next; // 满指针移动一步
            if (fast == slow) { //当快慢指针相遇的时候，证明有环，则进行入口处判断
                ListNode* index1 = fast;  // 定义在相遇点
                ListNode* index2 = head； // 定义在链表头
                while(index1 != index2) {
                    index1 = index1->next; 
                    index2 = index2->next;
                }
                return index1; //如果相遇了，返回相遇点，并且此处是入口处，详细看代码随想录的数学推导
            }
        }
        return NULL;     
    }
};
```

# 三、哈希表

总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

常用的哈希函数：数组，map，set



## 1、有效的字母异位词

因为字母是有限的，可以用数组来设计哈希

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int hash[26] ={0};
        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
        for (int i = 0; i < s.size(); i++) {
            hash[s[i] - 'a']++; 
        }
        for (int i = 0; i < t.size(); i++) {
            hash[t[i] - 'a']--;
        }
        for (int i=0; i<26; i++) {
            // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if (hash[i] != 0) {
                return false;
            }
        }
         // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        hash = [0]*26
        
        for i in s:
            # 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            hash[ord(i) - ord("a")] += 1
        for i in t:
            hash[ord(i) - ord("a")] -= 1
        for i in range(26):
            # record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if hash[i] != 0:
                return False
        return True
```

## 2、两个数的交集（set集合容器的过渡）

在 C++中，考虑set的三种方式：`set   unordered_set   multiset`(**需要后面再看视频教程补充**)

由于题目的要求更改，可以用数组实现hash

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**题目**：给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hash = [0]*1005  # 如果题目要求的长度是数组能够达到的，那么用数组哈希
        res = []
        for num in nums1:  # 遍历nums1中的元素，将对应元素的记录，用1代表hash对应元素出现过
            hash[num] = 1
        for num in nums2:
            if hash[num] == 1: # 判断出现的的hash数组元素索引是否有，如果有，添加到返回值
                res.append(num)
                hash[num] == 0  # 为了去重
        return res
```

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;   // 存放结果，之所以用set是为了给结果集去重，（set）自动去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end()); // 给nums_set赋值，浅拷贝
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## 3、两数之和（map映射）

**题目：**给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target`  的那 两个 整数，并返回它们的数组下标。     你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里**不能重复出现**。   你可以按任意顺序返回答案。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

此时就要选择另一种数据结构：`map` ，`map`是一种`key value`的存储结构，可以用`key`保存数值，用`value`在保存数值所在的下标。

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash_map = {} # 设置一个字典
        # 遍历nums里面的key和value
        for key, value in enumerate(nums):
            # 如果我的目标值在hash字典里面，那么返回对应hash的坐标和当前的坐标
            if target - value in hash_map: 
                return[hash_map[target - value], key]
            hash_map[value] = key # 如果没有找到，那么将当前nums的值做hash的key，nums的key做hash的value
        return []
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map; // 无序map key不可重复
        for (int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - value);
            if (iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

## **缺赎金信和快乐数**

## 4、四数相加（map）

**题目：**给你四个整数数组 `nums1、nums2、nums3 和 nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

`0 <= i, j, k, l < n`
       `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

1. 首先定义 一个unordered_map，`key放a和b两数之和`，`value 放a和b两数之和出现的次数`。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)]; //这一步很重要，不是单纯的+1，而是要统计a+b出现的次数
                }
            }
        }
        return count;
    }
};
```

```py
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        hash_map = {} # 创建空的map表，key-value
        for a in nums1:  # 遍历A,B两个数组
            for b in nums2:
                if a + b in hash_map:  # 当a+b key值出现在map内，将value值+1 
                    hash_map[a+b] += 1
                else:  # 否则赋给一个初值，如果不赋值，那么上面的if不会得到判断，也就是因为没有value值
                    hash_map[a+b] = 1
        count = 0   # 记录出现次数
        for c in nums3:
            for d in nums4:
                target = 0-(c+d) # 因为 a+b+c+d=0  所以 a+b=0-(c+d)
                if target in hash_map: # 判断0-(c+d) 在不在map中，有的话将value值传给count
                    count += hash_map[target]
       	return count
```

## 5、三数之和（双指针+去重）

**题目：**给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j、i != k 且 j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有**和为 0** 且**不重复**的三元组。

注意：答案中不可以包含重复的三元组。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;  // 双数组
        sort(nums.begin(), nums.end()); // 排序，如果返回的是值可以排序，如果是坐标就不行
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法， 不能影响left和right
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue; //不执行后面的  继续循环
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*所以不能写在判断前
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        nums.sort() # 不是返回下标而是返回数值，进行排序
        
        for i in range(n):
            if nums[i] > 0:
                return res        
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            
            left = i + 1
            right = n - 1
            while left < right:
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left+1]:
                        left += 1
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1
                    
                    right -= 1
                    left += 1
        return res

```

## 6、四数之和（在三数之和的基础上添加）

**题目：**给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且不重复的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

`0 <= a, b, c, d < n`
       `a、b、c` 和 `d` 互不相同
       ` nums[a] + nums[b] + nums[c] + nums[d] == target`
        你可以按 **任意顺序** 返回答案 。

相对于三数之和的区别，对C++，多一个剪枝的操作    **剪枝：**如果使用`nums[k] > target`的话，由于`nums`是排好序的，有可能数组全是负数，那么负数相加会更小，所以不能只有一个判断条件。所以判断剪枝的条件是`nums[k] > target && nums[k] >= 0`

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        
        for (int k = 0; k < nums.size(); k++) {
            //剪枝
            if (nums[k] > target &&  nums[k] >= 0) {
                break;
            }
            //去重
            if (k > 0 && nums[k] == nums[k-1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                //剪枝
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }
                // 去重
                if (i > k + 1 && nums[i] == nums[i-1]) continue;

                int left = i + 1;
                int right = nums.size() - 1;

                while (left < right) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long)(nums[k] + nums[i] + nums[left] + nums[right]) > target) {
                        right--;
                    }
                    
                    else if ((long)(nums[k] + nums[i] + nums[left] + nums[right]) < target) left++; 
                    else {
                        res.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left+1]) left++;
                        while (left < right && nums[right] == nums[right-1]) right++;
                        left++;
                        right--;
                    }            
                }
            }
        }
        return res;
    }
};
```

# 四、字符串

## 1、反转字符串

**题目：**编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 `O(1)` 的额外空间解决这一问题。

双指针法，向中间遍历即可。本体难度很低

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int i = 0, j = s.size() - 1;
        while (i < j) {
            swap(s[i], s[j]);
            i++;
            j--;
        }
    }
};
```

```py
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        i = 0
        j = len(s) - 1

        while i < j:
            s[i], s[j] = s[j], s[i]    # 牢记python的交换操作
            i += 1
            j -= 1
```

## 2、反转字符串2

**题目**：给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
		如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样

```py
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        """
        1. 使用range(start, end, step)来确定需要调换的初始位置
        2. 对于字符串s = 'abc'，如果使用s[0:999] ===> 'abc'。字符串末尾如果超过最大长度，则会返回至字符串最后一个值，这个特性可以避免一些边界条件的处理。
        3. 用切片整体替换，而不是一个个替换.
        """
        def reverse_substring(text):
            left, right = 0, len(text) - 1
            while left < right:
                text[left], text[right] = text[right], text[left]
                left += 1
                right -= 1
            return text
        res = list(s)
        for cur in range(0, len(s), 2*k):
            res[cur: cur + k] = reverse_substring(res[cur: cur + k])
        return ''.join(res)
                
```

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += (2 * k)) {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + i + k );
            } else {
                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                reverse(s.begin() + i, s.end());
            }
        }
        return s;
    }
};
```

## 3、替换空格（双指针，从后向前遍历）

之所以要考虑从后往前遍历，主要的原因是节省时间，实现O(n)的时间复杂度，如果双指针从头往后遍历，需要两层for循环，时间边长

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int OldLen = s.size();
        int count = 0; // 统计空格个数
        for (int i = 0; i < OldLen; i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        //扩大s的长度，因为原来的空格只有一个空间，而%20占三个，但是空格占了一个，所以扩大两倍count
        s.resize(OldLen + 2*count);
        int newLen = s.size();
        //从右往左遍历方便实现O(n)的时间复杂度
        //双指针，一个指向老的s， 一个指向新的s
        for (int i = newLen-1, j = OldLen - 1; j < i; i--, j--) {
            //遍历s[j] 来判断，此时的s[i]指向的新空间，后面都是空的
            if (s[j] != ' ') {
                s[i] = s[j];   
            }
            else {
                s[i] = '0';
                s[i-1] = '2';
                s[i-2] = '%';
                i -= 2;  //注意移动位置
            }
        }
        return s;
    }
};
```

## 4、翻转字符串里的单词（双指针方法，与数组第二题移除元素相似）

**题目：**给你一个字符串 `s` ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 `单词` 分隔开。

返回 `单词` 顺序颠倒且 `单词` 之间用单个空格连接的结果字符串。

注意：输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

```c++
class Solution {
public:
    // 反转字符串s中左闭右闭的区间[start, end]
    void reverse(string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);  // 双指针法，与反转字符串1相同的函数
        }
    }

    void yiChuBlank(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;  // 定义慢指针
        for (int fast = 0; fast < s.size(); ++fast) {
            if (s[fast] != ' ') {  //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' ';//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (fast < s.size() && s[fast] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[fast++];
                }
            }
        }
        s.resize(slow);  //slow的大小即为去除多余空格后的大小。
    }
        
    string reverseWords(string s) {
        yiChuBlank(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size()-1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```

本题的难点在于**移除多余空格**的各种判断，需要加强练习

## 5、实现strStr（KMP算法）

**1、什么是**`KMP`

说到`KMP`，先说一下`KMP`这个名字是怎么来的，为什么叫做`KMP`呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做`KMP`

**2、`KMP`有什么用**

KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。

没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。

不仅面试的时候可能写不出来，如果面试官问：**next数组里的数字表示的是什么，为什么这么表示？**

估计大多数候选人都是懵逼的。

**3、什么是前缀表**

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

1. 初始化

   ```c++
   int j = 0;
   next[0] = 0;
   for (int i = 1; i < s.size(); i++) 
   ```

2. 前后缀不相同的情况

   ```c++
   while (j>0 && s[i] != s[j]) { // 一直往前走，知道找到相同的
          j = next[j - 1]; //返回next数组前一个值对应的下标索引
   }
   ```

3. 前后缀相同的情况

   ```c++
   if (s[i] == s[j]) {  //前后缀相同的情况，j向后移动
                   j++;
               }
   ```

4. next数组赋值

   ```c++
   next[i] = j;  //更新当前next数组
   ```

```c++
void getNext(int* next, string &s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.size(); i++) {
            while (j>0 && s[i] != s[j]) { // 一直往前走，知道找到相同的
                j = next[j - 1]; //返回next数组前一个值对应的下标索引
            }
            if (s[i] == s[j]) {  //前后缀相同的情况，j向后移动
                j++;
            }
            next[i] = j;  //更新当前next数组
        }
    }
```

**题目：**给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  `-1` 。

尝试只用`KMP`算法来做

```c++
class Solution {
public:
    void getNext(int* next, string &s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.size(); i++) {
            while (j>0 && s[i] != s[j]) { // 一直往前走，知道找到相同的
                j = next[j - 1]; //返回next数组前一个值对应的下标索引
            }
            if (s[i] == s[j]) {  //前后缀相同的情况，j向后移动
                j++;
            }
            next[i] = j;  //更新当前next数组
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];  //创建next数组
        getNext(next, needle);  //得到next数组的所有元素
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            // 这一部分不太明白清晰，后续二刷的时候要在群里问问
            if (j == needle.size() ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

## 6、重复的子字符串（移动匹配和`KMP`）

当一个字符串`s：abcabc，`内部由重复的子串组成，那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s，所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin());
        t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // r  find函数在找不到指定值得情况下会返回string::npos。
        return false;
    }
};
```

**`KMP`**:

- 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串;

1. 如果 `next[len - 1] != 0`，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。
2. 最长相等前后缀的长度为：`next[len - 1]` (next数组的最后一位)。
3. 数组长度为：`len`。
4. 如果`len % (len - next[len - 1]) == 0` ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。

```c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        if (s.size() == 0) {
            return false;
        }
        int next[s.size()];
        getNext(next, s);
        int len = s.size();
        // 关键的判断，以及如何思考到使用KMP算法很重要
        if (next[len - 1] != 0 && len % (len - (next[len - 1])) == 0) {
            return true;
        }
        return false;
    }
};
```

# 五、栈与队列

## 1、用栈实现队列

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    /** Initialize your data structure here. */
    MyQueue() {

    }
    /** Push element x to the back of queue. */
    void push(int x) {
        stIn.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
        if (stOut.empty()) {
            // 从stIn导入数据直到stIn为空
            while(!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    /** Get the front element. */
    int peek() {
        int res = this->pop(); // 直接使用已有的pop函数
        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去
        return res;
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};

```

## 2、用队列实现栈

```c++
class MyStack {
public:
    queue<int> que;
    /** Initialize your data structure here. */
    MyStack() {

    }
    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    /** Get the top element. */
    int top() {
        return que.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};
```

## 3、有效的括号

**题目：**给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串 `s` ，判断字符串是否有效。有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。

- 左括号必须以正确的顺序闭合。
- 每个右括号都有一个对应的相同类型的左括号。

经典的栈问题，需要知道判断是否有效括号分三种

1. 第一种情况，字符串里左方向的括号多余了 ，所以不匹配。
2. 第二种情况，括号没有多余，但是 括号的类型没有匹配上。
3. 第三种情况，字符串里右方向的括号多余了，所以不匹配。

```c++
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) {  // 如果s的长度为奇数，一定不符合要求
            return false;
        }
        stack<char> st;
        for (int i =0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '[') st.push(']');
            else if (s[i] == '{') st.push('}');
            else if (st.empty() || st.top() != s[i]) {
                return false;
            }
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        return st.empty();
    }
};
```

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        
        for item in s:
            if item == '(':
                stack.append(')')
            elif item == '[':
                stack.append(']')
            elif item == '{':
                stack.append('}')
            elif not stack or stack[-1] != item:
                return False
            else:
                stack.pop()
        
        return True if not stack else False
```

```py
# 方法二，使用字典
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {
            '(': ')',
            '[': ']',
            '{': '}'
        }
        for item in s:
            if item in mapping.keys():
                stack.append(mapping[item])
            elif not stack or stack[-1] != item: 
                return False
            else: 
                stack.pop()
        return True if not stack else False
```

## 4、删除字符串中相邻重复项

```py
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []

        for i in range(len(s)):
            if not stack or s[i] != stack[-1]:
                stack.append(s[i])
            else:
                stack.pop()
        
        return "".join(stack) # 字符串拼接
```

```c++
class Solution {
public:
    string removeDuplicates(string S) {
        stack<char> st;
        for (char s : S) {
            if (st.empty() || s != st.top()) {
                st.push(s);
            } else {
                st.pop(); // s 与 st.top()相等的情况
            }
        }
        string result = "";
        while (!st.empty()) { // 将栈中元素放到result字符串汇总
            result += st.top();
            st.pop();
        }
        reverse (result.begin(), result.end()); // 此时字符串需要反转一下
        return result;

    }
};
```

使用string做栈可以不用反转

```c++
class Solution {
public:
    string removeDuplicates(string S) {
        string result;
        for(char s : S) {
            if(result.empty() || result.back() != s) {
                result.push_back(s);
            }
            else {
                result.pop_back();
            }
        }
        return result;
    }
};
```

## 5、逆波兰表达式

`逆波兰表达式`是二叉树的后序遍历方式（左右中）实现的，主要是方便计算机做四则运算

`逆波兰表达式：`

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 ) 。`

- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + *` 也可以依据次序计算出正确结果。

- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

主要还是栈的应用，遇到对应符号应该做相应的计算

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            }
            else {
                st.push(stoll(tokens[i]));
            }
        }
        int res = st.top();
        st.pop();  // 释放内存，再leetcode可以不用释放
        return res;
    }
};
```

```py
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    # eval() 函数用来执行一个字符串表达式，并返回表达式的值
                    int(eval(f'{second_num} {item} {first_num}'))   # 第一个出来的在运算符后面
                )
        return int(stack.pop()) # 如果一开始只有一个数，那么会是字符串形式的
```

## 6、滑动窗口最大值（用双端队列实现一个单调队列）

**题目：**给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 `滑动窗口中的最大值` 。

```c++
class Myque { //单调队列，从大到小
        deque<int> que;  //使用双端队列来实现
    // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 
    // 同时pop之前判断队列当前是否为空。
    public:
        void pop(int val) {
            if (!que.empty() && val == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。        
        void push(int val) {
            while (!que.empty() && val > que.back()) {
                que.pop_back();
            }
            que.push_back(val);
        }
        void getMaxVal() {
            return que.front();
        }
    };
```

```c++
class Solution {
public:
    class Myque {
        deque<int> que; //使用双端队列实现单调序列
    public:
        void pop(int val) { //当我要弹出的值是队列的首位元素时，做pop操作
            // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 
    // 同时pop之前判断队列当前是否为空。
            if (!que.empty() && val == que.front()) {
                que.pop_front();
            }
        }
        //添加值的时候，从最后开始比较，如果队列里面的值没有我要加入的大，那么弹出队尾元素，直到不满足条件
        // 同时要满足列表不为空的要求
        // 循环完之后，将val值插入尾部
        // 这样就保持了队列里的数值是单调从大到小的了。    
        void push(int val) {
            while (!que.empty() && val > que.back()) {
                que.pop_back();
            }
            que.push_back(val);
        }
        // 取最大值，队首的元素
        int getMaxVal() {
            return que.front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        Myque que; // 实例化单调队列
        vector<int> result;  // 创建一个返回容器
        // 先将前k个元素添加到单调队列中
        for (int i = 0; i < k; i++) {
            que.push(nums[i]);
        }
        // 添加完成后将最大值返回给result
        result.push_back(que.getMaxVal());
        // 从k的位置开始往后移动
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 先弹出队列的第一个元素弹出，保证单调队列的长度是K
            que.push(nums[i]); // 滑动窗口前，加入最后面的元素
            result.push_back(que.getMaxVal()); // 记录对应的最大值
        }
        return result;
    }
};
```

总结：本题的难点在于要实现一个单调队列，如果一开始没想到会很难，如果用暴力求解会导致超过时间限制，同时暴力解法的时间复杂度是`O（nk）`。实现单调队列的时候用的是双端队列`deque`，这是C++低层实现队列和栈的基础，通过这个来实现单调队列才能完成本题。需要多巩固

## 7、前K个高频元素（堆排序，要重读数据结构和算法相关书籍后再做）

**题目：**给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

# 六、二叉树

## 1、二叉树的理论基础：

### **满二叉树：**

如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

<img src="C:\Users\Ruoji\AppData\Roaming\Typora\typora-user-images\image-20230131120839443.png" alt="image-20230131120839443" style="zoom:50%;" />

### **完全二叉树：**

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2^(h-1)`  个节点。

<img src="C:\Users\Ruoji\AppData\Roaming\Typora\typora-user-images\image-20230131120943093.png" alt="image-20230131120943093" style="zoom:80%;" />

### **二叉搜索树：**

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

<img src="C:\Users\Ruoji\AppData\Roaming\Typora\typora-user-images\image-20230131121104477.png" alt="image-20230131121104477" style="zoom:80%;" />

### **平衡二叉搜索树**：

又被称为`AVL（Adelson-Velsky and Landis）`树，且具有以下性质：

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

<img src="C:\Users\Ruoji\AppData\Roaming\Typora\typora-user-images\image-20230131121222908.png" alt="image-20230131121222908" style="zoom:80%;" />

**一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！**

### **二叉树的存储方式：**

​			**二叉树可以链式存储，也可以顺序存储。**

​			那么链式存储方式就用指针， 顺序存储的方式就是用数组。

###  二叉树的遍历方式：

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

**这里前中后，其实指的就是中间节点的遍历顺序**

###  二叉树的定义

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 2、二叉树的递归遍历

这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

**以下以前序遍历为例：**

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

   ```c++
   void traversal(TreeNode* cur, vector<int>& vec)
   ```

   ```py
   def traversal(node: TreeNode):
   ```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接`return`，代码如下：

   ```c++
   if (cur == NULL) return;
   ```

   ```py
   if node == None: return
   ```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

   ```c++
   vec.push_back(cur->val);    // 中
   traversal(cur->left, vec);  // 左
   traversal(cur->right, vec); // 右    ----------前序遍历
   ```

   ```py
   traversal(node.left) # 左
   result.append(node.val) # 中
   traversal(node.right) # 右      -------中序遍历
   ```

前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

后序遍历

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []

        def traversal(node: TreeNode):
            if node == None:
                return
            traversal(node.left)
            traversal(node.right)
            result.append(node.val)

        traversal(root)
        return result
```

## 3、二叉树的迭代遍历

在遍历的时候，需要考虑入栈顺序和出栈顺序，例如在前序遍历的过程中，虽然前序是中左右，但是入场的顺序却是先右后左。

后序遍历反而比较容易直接修改： 前序`中左右`—>`中右左`—>`左右中` 后序。只需要将入栈的顺序变成先左后头=右，然后再对返回结果进行反转就可以得到后续遍历。

**前序遍历：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root == nullptr) return result;
        st.push(root);  // 将树输入到栈
        while (!st.empty()) {
            TreeNode* node = st.top();   //取到中间节点， 使用node才存
            st.pop();  // 弹出中节点
            result.push_back(node->val);  //取到此时的中节点的值
            if (node->right) st.push(node->right);  //将右节点入栈，为空不入
            if (node->left) st.push(node->left);    //将左节点入栈，为空不入
        }
        return result;
    }
};
```

**后续遍历：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left);
            if (node->right) st.push(node->right);
            
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
```

**中序遍历：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result; // 创建返回结果
        stack<TreeNode*> st;   // 构建Node栈
        TreeNode* cur = root;  // 设置一个指针指向root节点
        while (cur != nullptr || !st.empty()) {  // 当我的指针或栈不为空的时候处理
            if (cur != nullptr) { // 指针不为空，向后遍历，同时入栈
                st.push(cur);
                cur = cur->left; // 左中右
            }
            else { // 当指针指向空的时候，左边孩子节点为空，需要将节点记录，同时弹出栈头元素
                cur = st.top();
                st.pop();
                result.push_back(cur->val);  // 记录了cur指针指向的左节点的值              
                cur = cur->right;// 向右遍历
            }
        }
        return result;  // 返回结果
    }
};
```

## 4、使用统一的迭代遍历实现前中后三种遍历二叉树

统一迭代法的时候，只需要将前中后的原始顺序反向入栈即可：

- 前序：  `中左右—>右左中`
- 中序：  `左中右—>右中左`
- 后续：  `左右中—>中右左`

处理加入空指针记录中节点的值，利用这一位置来处理情况

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```

```C++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

